import React from 'react';
import { render, screen } from '@testing-library/react';
import { useTheme } from '@mui/material/styles';
import { Typography, Button } from '@mui/material';
import { CustomThemeProvider } from '@/context/ThemeProvider';
import { mockBrandingSettings } from '../utils/test-utils';
import * as useFontLoaderModule from '@/hooks/useFontLoader';

// Mock the useFontLoader hook
jest.mock('@/hooks/useFontLoader');
const mockUseFontLoader = useFontLoaderModule.useFontLoader as jest.MockedFunction<typeof useFontLoaderModule.useFontLoader>;

describe('CustomThemeProvider - Simple Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock useFontLoader to return ready status by default
    mockUseFontLoader.mockReturnValue({
      status: useFontLoaderModule.FontStatus.READY,
      error: undefined,
      retry: jest.fn(),
    });

    // Mock document methods to prevent DOM manipulation errors
    const mockElement = {
      id: '',
      textContent: '',
      remove: jest.fn(),
    };

    document.createElement = jest.fn().mockReturnValue(mockElement);
    document.getElementById = jest.fn().mockReturnValue(null);
    
    // Mock head and body using Object.defineProperty
    Object.defineProperty(document, 'head', {
      value: { appendChild: jest.fn(), removeChild: jest.fn() },
      writable: true,
    });
    
    Object.defineProperty(document, 'body', {
      value: { style: { display: '' }, offsetHeight: 100 },
      writable: true,
    });

    // Mock setTimeout
    jest.spyOn(global, 'setTimeout').mockImplementation((fn: any) => {
      if (typeof fn === 'function') fn();
      return 123 as any;
    });
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('should render children with theme provider', () => {
    render(
      <CustomThemeProvider brandingSettings={mockBrandingSettings}>
        <div data-testid="child">Test content</div>
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('child')).toBeInTheDocument();
  });

  it('should apply branding colors to theme palette', () => {
    const TestComponent = () => {
      const theme = useTheme();
      return (
        <div>
          <span data-testid="primary-color">{theme.palette.primary.main}</span>
          <span data-testid="secondary-color">{theme.palette.secondary.main}</span>
          <span data-testid="text-color">{theme.palette.text.primary}</span>
        </div>
      );
    };

    render(
      <CustomThemeProvider brandingSettings={mockBrandingSettings}>
        <TestComponent />
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('primary-color')).toHaveTextContent('#ff0000');
    expect(screen.getByTestId('secondary-color')).toHaveTextContent('#00ff00');
    expect(screen.getByTestId('text-color')).toHaveTextContent('#333333');
  });

  it('should apply font family to typography', () => {
    const TestComponent = () => {
      const theme = useTheme();
      return (
        <div>
          <span data-testid="font-family">{theme.typography.fontFamily}</span>
        </div>
      );
    };

    render(
      <CustomThemeProvider brandingSettings={mockBrandingSettings}>
        <TestComponent />
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('font-family')).toHaveTextContent('Arial, sans-serif');
  });

  it('should create button component overrides', () => {
    render(
      <CustomThemeProvider brandingSettings={mockBrandingSettings}>
        <Button variant="contained" data-testid="test-button">
          Test Button
        </Button>
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('test-button')).toBeInTheDocument();
  });

  it('should create typography component overrides', () => {
    render(
      <CustomThemeProvider brandingSettings={mockBrandingSettings}>
        <Typography data-testid="test-typography">
          Test Text
        </Typography>
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('test-typography')).toBeInTheDocument();
  });

  it('should handle missing theme properties gracefully', () => {
    const incompleteSettings = {
      ...mockBrandingSettings,
      theme: {
        ...mockBrandingSettings.theme,
        theme_color: '#000000', // Use a default value instead of undefined
        button: {
          primary_color: '#000000',
          secondary_color: '#ffffff',
          hover_color: '#000000',
          border_color: '#cccccc',
        },
      },
    };

    expect(() => {
      render(
        <CustomThemeProvider brandingSettings={incompleteSettings}>
          <div>Test</div>
        </CustomThemeProvider>
      );
    }).not.toThrow();
  });

  it('should handle different font families', () => {
    const customSettings = {
      ...mockBrandingSettings,
      theme: {
        ...mockBrandingSettings.theme,
        font_family: 'Roboto, sans-serif',
      },
    };

    const TestComponent = () => {
      const theme = useTheme();
      return (
        <div>
          <span data-testid="custom-font">{theme.typography.fontFamily}</span>
        </div>
      );
    };

    render(
      <CustomThemeProvider brandingSettings={customSettings}>
        <TestComponent />
      </CustomThemeProvider>
    );

    expect(screen.getByTestId('custom-font')).toHaveTextContent('Roboto, sans-serif');
  });
});
